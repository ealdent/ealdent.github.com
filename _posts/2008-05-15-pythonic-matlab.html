---
layout: post
title: "Pythonic Matlab"
tags: ["computer science", "computer science", "functions", "functions", "matlab", "matlab", "memory", "memory", "memory management", "memory management", "programming", "programming", "programming languages", "programming languages", "python", "python"]
---
Original post can be found at:  <a href="http://ealdent.wordpress.com/2008/05/15/pythonic-matlab/" target="_blank">http://ealdent.wordpress.com/2008/05/15/pythonic-matlab/</a><br /><br />
<p>I attended a Matlab training seminar yesterday with the dual topics of "Advanced Matlab Programming" and "Distributed and Parallel Computing."  Of the two, the Advanced section was more interesting, though my original motivation for going was the parallel computing part.  In the morning, I felt like it was going to be a waste because my Matlab programming skills are weak, and if my advisor had not strongly suggested I attend, I might've skipped it.  I'm glad he did, because it was surprisingly enjoyable and I felt like it was right on my level.  This might be because programming in Matlab isn't especially hard or different from other programming languages and I know enough to get by already.  Or it might be because Matlab is becoming a little more like Python.<!--more--></p>
<p>First let me clarify by saying that I'm not suggesting Matlab is copying Python (though they may be) or that Python has the market cornered on the similarities I'm about to talk about (it doesn't).  Also, I have no idea when this stuff was introduced to Matlab, so it might have all been there for years.</p>
<p>The first thing of interest to me was the discussion about memory management in Matlab.  Suppose you create a matrix and store it in the variable X.  Next, you assign X to Y:  <code>Y = X</code>.  Here, Y acts as a pointer to the data pointed to by X.  If you clear X, Y still points to the data, so it continues to reside in memory until Y has been cleared also.  Now if you modify Y, perhaps like so:  <code>Y(1,1) = 2</code>, my thought was that both X and Y would be affected and the memory used would stay the same.  However, that is not the case, thanks to the <a href="http://en.wikipedia.org/wiki/Blas" target="_blank">BLAS</a> and <a href="http://en.wikipedia.org/wiki/LAPACK" target="_blank">LAPACK</a> libraries that require matrices to be contiguous in memory.  So when you modify Y as above, it creates a modified copy in memory that Y now points to, while X remains pointing to the same, unmodified data.  This is decidedly not Pythonic, since in Python that modification would have updated both X and Y, and they still would be pointing to the same thing in memory.</p>
<p>The next set of interesting things were functions.  Here is where things struck me as Pythonic.   You can declare a simple function in an m-file like so:</p>
<code>function Y = square(x)
Y = x.^2
end</code>
<p>Here the <code>end</code> is optional.  Like in Python, you can use function handles.  This lets you do cool things like decide on the fly which operation you can apply to a matrix without having to worry about record-keeping and if checks (I'm not going into this any further).  To demonstrate the function handle, here is one possibility:</p>
<code>fh = @sin
fh(pi)
fh = @cos
fh(pi)</code>
<p>We call the function handle fh on the same input, but get two different results:  0 and -1.  Matlab also lets you create factory functions like in Python:</p>
<code> function Y = makeF(a,b)
Y = @makeFHelper;
function Z = makeFHelper(x)
Z = a * sin(x) + b;
end
end
</code>
<p>This returns a function handle to the subfunction makeFHelper with the parameters you passed hard-coded in the function produced.  So you could create two different functions:</p>
<code>Y1 = makeF(2,3)
Y2 = makeF(3,-1)</code>

and when you execute them:

<code>Y1(pi/3)
Y2(pi/3)</code>
<p>you get two different results: 4.7321 and 1.5981.  If I had known about this before, I might've put more effort into learning Matlab programming, since it would have come in handy for a couple assignments this semester.</p>
