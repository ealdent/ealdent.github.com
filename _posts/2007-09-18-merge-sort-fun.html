---
layout: post
title: "Merge sort fun"
tags: ["algorithms", "algorithms", "code", "code", "java", "java", "memory", "memory", "merge sort", "merge sort", "programming", "programming", "sort", "sort"]
---
Original post can be found at:  http://ealdent.wordpress.com/2007/09/18/merge-sort-fun/<br /><br />
Suppose you have an array of floating point numbers with each index into the array being an id number corresponding to some external data structure.  You want to sort this array, but in doing so you would destroy the references to the id numbers, since the indexes of the array would no longer correspond to the correct id numbers in the external data structure.  For example, let's say we are dealing with customers of a store and each value in the array is their current balance.

<code>balances = {25.61, 13.45, 89.75, 21.2, 96.50}</code>

Each index in the balances array corresponds to an index in some other array, say:

<code>names = {</code><code>"Marjory Stewart-Baxter", </code><code>"Hubert Cumberdale", "Barbara Logan-Price", "Jeremy Fisher", "Mable"}</code>

<!--more-->
If we were to merely sort the <code>balances</code> array in descending order, the result would be that the balance of $96.50 would no longer correspond to Mable but to Marjory Stewart-Baxter.  Marjory hates Mable enough already, we wouldn't want her having to pay her bills, as well.  Of course, an easy solution would be to use a <code>Map</code> with the name of the person as the key and the balance as the value.  The problem comes in that maps are slower to access and consume more memory than arrays, so could be less desirable in situations where speed and memory are important.

In Python, it is easy to sort two lists of this kind.  Make each value in the list a tuple (balance, name) and then use the built in sort function:

[sourcecode language='python']

balnames = zip(balances, names)
balnames.sort()

[/sourcecode]

However, in Python a list does not an array make.  Memory consumption can get messy if you are using complicated structures (especially dictionaries).  Even if you're using only tuples of primitives, you consume more memory than a simple array would.  I've been doing some Java coding over the past few days and ran into this problem.  My solution is an implementation of merge sort that sorts both the array of values and keeps track of the indexes in a separate array.  Memory consumption is still not optimal, since merge sort is O(n) in memory and keeping track of the indexes doubles that again.

[sourcecode language='java']
/**
 * Modified merge sort algorithm for sorting an array
 * in descending order while keeping track of indexes.
 *
 * @param indexes array of the original indexes for items in the data array
 * @param data array of the values that the array will be sorted according to (doubles)
 */
public static void mergeSort(int [] indexes, double [] data) {
&nbsp;&nbsp;&nbsp;&nbsp;if (indexes.length &amp;lt;= 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp; // stopping condition

&nbsp;&nbsp;&nbsp;&nbsp;int split = indexes.length / 2;
&nbsp;&nbsp;&nbsp;&nbsp;int mod = indexes.length % 2;
&nbsp;&nbsp;&nbsp;&nbsp;int [] indexes_l = new int[split];
&nbsp;&nbsp;&nbsp;&nbsp;int [] indexes_r = new int[split + mod];
&nbsp;&nbsp;&nbsp;&nbsp;double [] data_l = new double[split];
&nbsp;&nbsp;&nbsp;&nbsp;double [] data_r = new double[split + mod];

&nbsp;&nbsp;&nbsp;&nbsp;// split the arrays into two parts
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &amp;lt; indexes.length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i &lt; split) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexes_l[i] = indexes[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_l[i] = data[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexes_r[i - split] = indexes[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_r[i - split] = data[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// recursive step
&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(indexes_l, data_l);
&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(indexes_r, data_r);

&nbsp;&nbsp;&nbsp;&nbsp;// now handle merge
&nbsp;&nbsp;&nbsp;&nbsp;int idx_l = indexes_l.length - 1;
&nbsp;&nbsp;&nbsp;&nbsp;int idx_r = indexes_r.length - 1;
&nbsp;&nbsp;&nbsp;&nbsp;while (idx_l &gt;= 0 &amp;amp;&amp;amp; idx_r &gt;= 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add the smaller item to the right of the array
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this produces descending order, in case of tie
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// right side goes in first
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data_r[idx_r] &gt; data_l[idx_l]) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[idx_r + idx_l + 1] = data_l[idx_l];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexes[idx_r + idx_l + 1] = indexes_l[idx_l];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx_l--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[idx_r + idx_l + 1] = data_r[idx_r];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexes[idx_r + idx_l + 1] = indexes_r[idx_r];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx_r--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;while (idx_l &gt;= 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[idx_l] = data_l[idx_l];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexes[idx_l] = indexes_l[idx_l];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx_l--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;while(idx_r &gt;= 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[idx_r] = data_r[idx_r];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexes[idx_r] = indexes_r[idx_r];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx_r--;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
[/sourcecode]

Find any bugs or a better way of doing it?  Please let me know.
