---
layout: post
title: "brainfscking set theory"
tags: ["arithmetic", "arithmetic", "brainfuck", "brainfuck", "code", "code", "computer science", "computer science", "math", "math", "mathematics", "mathematics", "set theory", "set theory"]
---
<hr>Original post can be found at:  <a href="http://ealdent.wordpress.com/2007/12/03/brainfscking-set-theory/" target="_blank">http://ealdent.wordpress.com/2007/12/03/brainfscking-set-theory/</a><br /><br />
<p align="justify">I mentioned the esoteric programming language <a href="http://mendicantbug.com/2007/11/28/brainfsck/">brainfuck</a> a little while back.  It consists of 8 operations and was created in order to make the smallest compiler in the world (I think the current best is 174 bytes).  I was reading a post over on <a href="http://scienceblogs.com/goodmath/" target="_blank">Good Math, Bad Math</a> that defines <a href="http://scienceblogs.com/goodmath/2007/11/from_sets_to_arithmetic.php" target="_blank">arithmetic in terms of sets</a>.  Pretty basic if you've done anything with set theory, but Mark has a clear way of explaining things so I usually try to read all of his posts.  I've been playing catch-up today.  It struck me immediately how closely the set form that Mark describes matches the syntax/logical structure of brainfuck.  So I decided to play around a little.  Read on for more.<!--more--></p>
<p align="justify">Anyhow, his explanation for the construction of addition is as follows.  Given that we have ordered pairs of the form (x,y) -- see his post for a more formal definition of this -- we can define the function of addition as a mapping of the ordered pair <code>(x,y)</code> to <code>z</code> according to the following rules:</p>

<ol>
	<li>if x = 0, z = y</li>
	<li>if y = 0, z = x</li>
	<li>else, let x' = successor(x) and let y' = predecessor(y).  z = Add(x', y')</li>
</ol>
<p align="justify">This is arithmetic for the natural numbers and in a previous post he showed that every number except 0 has a predecessor and every number has a successor.  So basically addition is the process of decrementing y until it reaches zero while incrementing x.  For example, Add(3,4) =</p>

<ul>
	<li>Add(4,3)</li>
	<li>Add(5,2)</li>
	<li>Add(6,1)</li>
	<li>Add(7,0)</li>
</ul>
<p align="justify">At which point rule 2 fires and z = x = 7.  So in brainfuck, we would have the following program for adding two numbers:</p>

<blockquote><code>,&gt;,[-&lt;+&gt;]&lt;.</code></blockquote>
<p align="justify">This reads in two numbers (,&gt;,), decrements the second until it reaches zero while incrementing the first ([-&gt;+&lt;]) and then outputs the first number(&lt;.).</p>
<p align="justify">Multiplication is similarly defined, with the rules being:</p>

<ul>
	<li>if x = 0, z = 0</li>
	<li>if y = 0, z = 0</li>
	<li>else z = Add(y, Mult(predecessor(x),y))</li>
</ul>
<p align="justify">This is more complicated because we have a nested function and brainfuck lives up to its name.  So the solution I came up with was to copy the value of x into another variable and then decrement the temp variable for x while incrementing the solution and the original variable again.  Then loop over this y times.</p>

<blockquote><code>,&gt;,[&lt;[-&gt;&gt;+&lt;&lt;]&gt;&gt;[-&gt;+&lt;&lt;&lt;+&gt;&gt;]&lt;-]&gt;&gt;.</code></blockquote>
The pseudocode for this is
<ol>
	<li>read in x and y</li>
	<li>while y &gt; 0:
<ol>
	<li>while x &gt; 0:
<ol>
	<li>decrement x</li>
	<li>increment temp_x</li>
</ol>
</li>
	<li>while temp_x &gt; 0:
<ol>
	<li>decrement temp_x</li>
	<li>increment z</li>
	<li>increment x</li>
</ol>
</li>
	<li>decrement y</li>
</ol>
</li>
	<li>output z</li>
</ol>
